const crypto = require('crypto');
const dotenv =require('dotenv');
let secretstring;

class Transaction {
  /**
   * @param {string} fromAddress
   * @param {string} toAddress
   * @param {number} amount
   */
  constructor(fromAddress, toAddress, amount) {
    this.fromAddress = fromAddress;
    this.toAddress = toAddress;
    this.amount = amount;
    this.timestamp = Date.now();
    this.signature = null;
  }

  /**
   * Creates a SHA256 hash of the transaction
   *
   * @returns {string}
   */
  calculateHash() {
    return SHA256(this.fromAddress + this.toAddress + this.amount + this.timestamp)
      .toString();
  }

  /**
   * Signs a transaction with the given signingKey (which is an Elliptic keypair
   * object that contains a private key). The signature is then stored inside the
   * transaction object and later stored on the blockchain.
   
   */
  signTransaction(priv) {
    // You can only send a transaction from the wallet that is linked to your
    // key. So here we check if the fromAddress matches your publicKey
    if (!this.fromAddress == `FORDYx${crypto.createHash('sha256').update(priv).digest('hex')}`) {
       return 'You cannot sign transactions for other wallets!';
    }
/* faild attempt
    if (!blockchain.getBalanceOfAddress(this.fromAddress) >= this.amount) {
       return 'you dont have enough funds';
    }
*/
     if(this.fromAddress == null || this.fromAddress == 'FORDYx0000000000000000000000000000000000000000000000000000000000000000') {
        this.signature = '0000000000000000000000000000000000000000000000000000000000000000';
     } 
   if (this.fromAddress !== null) {
   this.signature = crypto.createHash('sha256').update(this.fromAddres+priv+this.toAddres+this.amount+this.timestamp).digest('hex');
   return 'success';
  }
}

  /**
   * Checks if the signature is valid (transaction has not been tampered with).
   * It uses the fromAddress as the public key.
   *
   * @returns {boolean}
   */
  isValid(priv) {
    // If the transaction doesn't have a from address we assume it's a
    // mining reward and that it's valid. You could verify this in a
    // different way (special field for instance)
    if (this.fromAddress === null) return true;

    if (!this.signature || this.signature.length === 0) {
     if (!this.fromAddress && this.signature == null) {
        return false;
      }
    }
/* at lest i tried :(
     if (!blockchain.getBalanceOfAddress(this.fromAddress) >= this.amount) {
       return false;
    }
*/
   if (this.fromAddress && this.signature == null) {
    return true;
  } else {
 let tmp = crypto.createHash('sha256').update(this.fromAddres+priv+this.toAddres+this.amount+this.timestamp).digest('hex');
return (this.signature == tmp)
    }
  }
}


class Block {
  /**
   * @param {number} timestamp
   * @param {Transaction[]} transactions
   * @param {string} previousHash
   */
  constructor(timestamp, transactions, previousHash = '', nonce) {
    this.previousHash = previousHash;
    this.timestamp = timestamp;
    this.transactions = transactions;
    this.nonce = nonce;
    this.hash = this.calculateHash();
  }

  /**
   * Returns the SHA256 of this block (by processing all the data stored
   * inside this block)
   *
   * @returns {string}
   */
  calculateHash() {
   return crypto.createHash('sha256').update(this.previousHash + this.timestamp + JSON.stringify(this.transactions) + this.nonce).digest('hex');
  }

  /**
   * Starts the mining process on the block. It changes the 'nonce' until the hash
   * of the block starts with enough zeros (= difficulty)
   *
   * @param {number} difficulty
   */



  mineBlock(difficulty, block) {
    while (block.hash.substring(0, difficulty) !== Array(difficulty + 1).join('0')) {
      block.nonce++;
      block.hash = this.calculateHash();
    }

    console.log(`Block mined: ${block.hash}`);
  }

  /**
   * Validates all the transactions inside this block (signature + hash) and
   * returns true if everything checks out. False if the block is invalid.
   *
   * @returns {boolean}
   */
  hasValidTransactions() {
    for (const tx of this.transactions) {
      if (!tx.isValid()) {
        return false;
      }
    }

    return true;
  }
}

class Blockchain {
  constructor() {
    this.chain = [this.createGenesisBlock()];
    this.difficulty = 2;
    this.pendingTransactions = [];
    this.miningReward = 100;
  }

  /**
   * @returns {Block}
   */
  createGenesisBlock() {
    return new Block(Date.parse('2017-01-01'), [], '0');
  }

  /**
   * Returns the latest block on our chain. Useful when you want to create a
   * new Block and you need the hash of the previous Block.
   *
   * @returns {Block[]}
   */
  getLatestBlock() {
    return this.chain[this.chain.length - 1];
  }

createAddress(memo) {
  let a, b, c, d, tmp;
  d = [];
  b = crypto.createHash('sha256').update(memo + `${(Math.random(100000000000000000000,1100000000000000000000) * Math.random(100000000000000000000,1100000000000000000000))}`).digest('hex');
  b = JSON.stringify(b);
  c = crypto.createHash('sha256').update(b).digest('hex');
  c = JSON.stringify(c);
  b = b.split('');
  c = c.split('');
  b.splice(0,1);
  b.splice(b.length-1,1);
  c.splice(0,1);
  c.splice(c.length-1,1);
  for(let i=0;i<128;i++) {
     let tmp = Math.random(0,1);
     if(b.length == 0) {
        c =  c.join('');
        d.push(c);
        break;
     }
     if(c.length == 0) {
        b = b.join('');
        d.push(b);
        break;
     }
     if(tmp<0.5) {
        d.push(b[0]);
        b.splice(0,1);
     }
      if(tmp>0.5) {
        d.push(c[0]);
        c.splice(0,1);
     }
  }
  d = d.join('');
  a = crypto.createHash('sha256').update(d).digest('hex');
  a = JSON.stringify(a);
  a = `FORDYx${a}`;
  tmp =  a.split('"');
  a = tmp[0] + tmp[1];

  return [a, d];
}

getNewminingblock() {
    let block = new Block(Date.now(), this.pendingTransactions, this.getLatestBlock().hash, 0);
    return block;
}

addblock(block, address) {
    this.minePendingTransactions(address,block);
}

  minePendingTransactions(miningRewardAddress, block) {
    let difficulty = 4;
    const rewardTx = new Transaction('FORDYx0000000000000000000000000000000000000000000000000000000000000000', miningRewardAddress, this.miningReward);
    this.pendingTransactions.push(rewardTx);
    if (block.nonce == 0) {
         while (block.hash.substring(0, difficulty) !== Array(difficulty + 1).join('0')) {
      block.nonce++;
      block.hash = block.calculateHash();
    }

    console.log(`Block mined: ${block.hash}`)
    this.chain.push(block);
    this.pendingTransactions = [];
    }
  }

  /**
   * Add a new transaction to the list of pending transactions (to be added
   * next time the mining process starts). This verifies that the given
   * transaction is properly signed.
   *
   * @param {Transaction} transaction
   */
  addTransaction(transaction, priv) {
    if (!transaction.fromAddress || !transaction.toAddress) {
      if (!transaction.fromAddress == null) { 
          return 'Transaction must include from and to address';
      }
    }

   // Verify the transactiion
    if (!transaction.isValid(priv)) {
        return  'Cannot add invalid transaction to chain';
    }
    
    if (transaction.amount <= 0) {
        return 'Transaction amount should be higher than 0';
    }

    this.pendingTransactions.push(transaction);
    return 'success';
  }

  /**
   * Returns the balance of a given wallet address.
   *
   * @param {string} address
   * @returns {number} The balance of the wallet
   */
  getBalanceOfAddress(address) {
    let balance = 0;

    for (const block of this.chain) {
      for (const trans of block.transactions) {
        if (trans.fromAddress === address) {
          balance -= trans.amount;
        }

        if (trans.toAddress === address) {
          balance += trans.amount;
        }
      }
    }

    return balance;
  }

  /**
   * Returns a list of all transactions that happened
   * to and from the given wallet address.
   *
   * @param  {string} address
   * @return {Transaction[]}
   */
  getAllTransactionsForWallet(address) {
    const txs = [];

    for (const block of this.chain) {
      for (const tx of block.transactions) {
        if (tx.fromAddress === address || tx.toAddress === address) {
          txs.push(tx);
        }
      }
    }

    return txs;
  }

  /**
   * Loops over all the blocks in the chain and verify if they are properly
   * linked together and nobody has tampered with the hashes. By checking
   * the blocks it also verifies the (signed) transactions inside of them.
   *
   * @returns {boolean}
   */
  isChainValid() {
    // Check if the Genesis block hasn't been tampered with by comparing
    // the output of createGenesisBlock with the first block on our chain
    const realGenesis = JSON.stringify(this.createGenesisBlock());

    if (realGenesis !== JSON.stringify(this.chain[0])) {
      return false;
    }

    // Check the remaining blocks on the chain to see if there hashes and
    // signatures are correct
    for (let i = 1; i < this.chain.length; i++) {
      const currentBlock = this.chain[i];

      if (!currentBlock.hasValidTransactions()) {
        return false;
      }

      if (currentBlock.hash !== currentBlock.calculateHash()) {
        return false;
      }
    }

    return true;
  }
}



module.exports.Blockchain = Blockchain;
module.exports.Block = Block;
module.exports.Transaction = Transaction;
